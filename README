<div style="text-align: justify">
In the header file image-comp.h:

I defined: 1) a structure for the pixel matrix from the *.ppm file which contains the three colors of type unsigned char: red, green, blue; 2) a structure for the quaternary tree that contains the coordinates (x, y) of the area from the pixel matrix assigned to a node, the size of the area assigned to the node, the level at which the node is located in the quaternary tree, the color structure and the 4 children of the tree; 3) 2 structures for the queue, the first for the node and the second for the queue itself.

The first 6 functions are related to the queue: creating the node, creating an empty queue, checking if a queue is empty, enqueue - adding an element at the end, dequeue - removing the first element, and freeQueue, freeing memory.

In the divisions function, I created the quaternary tree based on the pixel matrix. The function receives as a parameter the pixel matrix, a double pointer to the root so that an update is made each time a new node is created and this becomes practically the new root. I initialized the first node in the tree, allocating memory to it, and then I started to calculate the arithmetic averages for the three colors according to the requirement. I then assigned the respective value to the node in the tree and updated the root as this newly formed node. I calculated the similarity score, and depending on this, if it is greater than the threshold imposed on the command line, the node is of type 0, i.e. internal, and in this case, I recursively called the divisions function so that each subtree corresponding to the child is formed in depth, starting from the respective coordinates and having the size halved. If the similarity score is less than the provided factor, the node is of type 1, i.e. it is a leaf node.

To find out the number of levels in the quaternary tree, I used the heightTree function which calculates the maximum number of arcs from the root node to the farthest leaf. I recursively searched the height of each child, then compared these heights between them and returned the maximum height + 1.

To calculate the number of blocks in the image for which the similarity score is less than or equal to the provided factor, I calculated the number of leaves on each branch, also recursively, and returned the total number of leaves in the tree. (If the similarity score is less than or equal to the imposed threshold, that node is not divided anymore, therefore the number of leaves is searched).

For the size of the square side for the largest area in the image that remained undivided, I applied the same principle as at height.

The next 2 functions are to write to the binary file. Through the write_info function, I write the information on the level, and if it is a leaf node, I also write the RGB values. From level 1, I recursively call the function for the previous level, so that I also go through the children of the parent node. The write_info_order function writes to me in order, starting with the first level and up to the last.

The create_tree function reads the data from the binary file and creates the quaternary tree at the same time. To start, I initialize the first node in the tree and create an empty queue in which I add this first node. I use the queue because in the binary file, the nodes are on the level. As long as I have elements in the queue, I remove the first element, assign it to a certain node (it is a general node that continues the construction of the tree), read from the binary file the type of this node and check if it is type 0 or 1. If it is type 1, i.e. leaf node, I read the next 3 values from the file which represent the colors and assign them to the node. If the node is internal, I start creating the child nodes. Here the information for each node must be written, because in the file, the nodes are on the level, and recursively they would be arranged in depth (depth vs breadth). I then add each child node to the queue. Finally, I free the memory for the queue and return the parent node and implicitly the tree.

The decompression function assigns the data from the quaternary tree to the pixel matrix. Then it is practically the same thing as the divisions function, only in reverse.

The ppm function writes the information from the matrix to the *.ppm file, in the corresponding binary part.

The last function frees the memory for the tree.


In the image-comp.c file:

To start, I checked if the number of arguments from the command line is 5, so that the input file is read correctly, being the 4th argument. I opened the *.ppm file from where I read in text format the header: P6, width, height, and maxColor, then, using fseek, I moved the cursor one byte to the right, passing the whitespace that delimits the text part from the binary part. I allocate memory for the pixel matrix and read the data from the binary file into it. I close the *.ppm file. I get the factor from the command line using the atoi function which transforms the string of characters read in the command line into an int number. I initialize the quaternary tree as being NULL and call the divisions function which creates the tree. From now on I just call the functions corresponding to the information I write in the text file: the number of levels, the number of leaves corresponding to the number of blocks in the image for which the similarity score is less than or equal to the provided factor and the size of the square side for the largest area that remained undivided. I open the output text file, write the corresponding information and close it. Then I open the binary output file (argument 5 in the command line), write width (or height, it doesn't matter since they are equal) and call the binary writing function write_info_order which has as parameters the tree and the out file. I close the file and free the memory for the matrix and the tree.

When I have 4 arguments on the command line, I open the input file which is the 3rd argument. I read from the binary file the first element, which is the size of the image. I create the tree by calling the create_tree function and close the reading file. I allocate memory for the pixel matrix, call the decompression function and open the output file (argument 4 on the command line). I write in the text part the usual data for a *.ppm file: P6, width, height, and 255, then I call the ppm function described above. I free the memory for the matrix and the tree and close the file.
</div>


